# 1장
- 진짜 전문가는 나쁜 코드를 양산하면 기한을 맞추지 못하는 것을 안다
- 엉망진창인 생태로 인해 속도가 곧바로 늦어지고 결국 기한을 놓친단
- 기한을 맞추는 유일한 방법은, 그러니까 빨리 가는 유일한 방법은 언제나 코드를 최대한 깨끗하게 유지하는 습관이다
- 깨끗한 코드는 한 가지에 집중한다. 각 함수와 클래스와 모듈은 주변 상황에 현혹되거나 오염되지 않은 채 한길만 걷는다
- 이 책의 핵심: 중복을 피하라, 한 기능만 수행해라, 제대로 표현하라, 작게 추상화해라

# 2장 의미있는 이름
- 따로 주석이 필요하다면 의도를 분명히 드러내지 못했다는 말이다
- 나름대로 널리 쓰이는 의미가 있는 단어를 다른 의미로 사용해도 안 된다: hp, aix, sco
- 서로 흡사한 이름을 사용하지 않는다: XYZControllerForEfficientHandlingOfStrings vs XYZControllerForEfficientStorageOfStrings
- 소문자 L, 대문자 O는 절대 쓰지 않는다
- 컴파일러를 통과할지라도 연속된 숫자를 덧붙이거나 불용어를 추가하는 방식은 적절하지 못하다: a1,a2,...,aN
- Info나 Data는 a, an, the와 같이 의미가 불분명하다
- 명확한 관례가 없다면 변수 moneyAmount, money, customerInfo, customer, accountData, account는 헷갈린다 => 읽는 사람이 차이를 알도록 이름을 지어라
- 검색하기 쉬운 이름을 사용해라...IntelliJ 검색기능을 사용할때 검색하기 쉬운 이름을 사용해야 읽기 편하다
- 클래스 이름: 명사나 명사구가 적합하다. Manager, Processor, Data, Info등은 피한다
- 메서든 이름: 동사나 동사구가 적합하다. get, set, is를 사용한다
- 생성자를 중복 저의 할 때는 정적 팩토리 메소드를 활용한다: Complex 중복 정의 = Complex.FromRealNumber(2.0) vs Complex felcrumPoint = new Complex(23.0)

# 3장 함수
- 나쁜 함수의 징표: 다양한 추상화 수준, 너무 긴 함수, 중첩된 if 문...
- 함수를 만드는 첫번째 규칙은 "작게"이다, 두번째도 "작게"
- 함수는 한 가지를 해야 한다. 그 한가지를 잘해야 한다. 그 한가지만을 해야 한다.
- 하지만 한 가지만 하는 함수는 만들기 어렵다 ==> 힌트: 단순히 표현이 아니라 의미있는 이름으로 다른 함수를 추출할 수 있다면 그 함수는 한 가지만 하는게 아니다
- 함수가 확실히 한가지 작업만 하려면 함수 내 모든 문장의 추상화 수준이 동일해야 한다: getHtml()(high), PathParser.render(pagePath)(medium), append("\n") (low)
- 한 함수 내에 추상화 수준을 섞으면 읽는 사람이 헷갈린다.
- 좋은 함수 = 한 함수 다음에는 추상화 수준이 한 단계 낮은 함수가 온다. 함수 추상화 수준이 한 번에 한 단계씩 낮아진다
- 서술적인 이름: 이름이 길어도 괜찮다. 길고 서술적인 이름이 짧고 아름다운 이름보다 좋다. 길고 서술적인 이름이 길고 서술적인 주석보다 좋다.
- 함수에서 이상적인 인수 개수는 0개, 다음은 1개, 그 다음은 2개, 그 다음은 3개다...4개는 쓰지말자 => 객체로 묶거나, 필드변수를 이용한다
- 부수효과는 거짓말이다. 함수에서 한 가지를 하겠다고 약속하고선 남몰래 다른 것도 하니까...temporal coupling이나 order dependency에 빠질 수 있다
- 일반적으로 출력 인수는 피해야 한다...함수에서 상태를 변경해야 한다면 함수가 속한 상태를 변경하는 방식을 택한다
- 함수는 뭔가를 수행하거나 뭔가에 답하거나 둘 중 하나만 해야한다. 객체 상태를 변경하거나 객체 정보를 반환하거나 둘 중 하나다
- 함수는 한가지 작업만 해야 한다. 오류 처리도 한 가지 작업에 속한다
- 중복은 문제다. 코드길이가 늘어날뿐만 아니라 알고리즘이 변하면 네 곳이나 손봐야하니까. 게다가 어느 한곳이라도 빠드리는 바람에 오류가 발생할 확률도 네배나 높다.
- 중복은 소프트웨어에 만악의 근원이다. 소프트웨어는 중복을 없애는 방향으로 발전해 왔다.

# 4장 주석
- 오래되고 조잡한 주석은 거짓과 잘못된 정보를 퍼뜨려 해악을 미친다
- 주석을 달 때마다 자신에게 표현력이 없다는 사실을 푸념해야 마땅하다
- 특별한 이유 없이 의무감으로 혹은 프로세스에서 하라고 하니까 마지못해 주석을 단다면 전적으로 시간 낭비다
- 같은 이야기를 중복해서는 안 된다

# 5장 형식 맞추기
- 프로그래머라면 형식을 깔끔하게 맞춰 코드를 짜야 한다
- 팀으로 일한다면 팀이 합의해 규칙을 정하고 모두가 그 규칙을 따라야 한다.
- 필요하다면 규칙을 자동으로 적용하는 도구를 활용한다.
- 소스파일도 신문 기사와 비슷하게 작성한다
- 이름도 간단하면서 설명이 가능하게 짓는다
- 이름만 보고도 올바른 모듈을 살펴보고 있는지 아닌지를 판단할 정도로 신경 써서 짓는다
- 소스 파일 첫 부분은 고차원 개념과 알고리즘을 설명한다
- 아래로 내려갈수록 의도를 세세하게 묘사한다
- 마지막에는 가장 저차원 함수와 세부 내역이 나온다
- 각 행은 수식이 나 절을 나타내고, 일련의 행 묶음은 완결된 생각 하나를 표현한다
- 생각 사이는 빈 행을 넣어 분리해야 마땅하다
- 서로 밀접한 개념을 세로로 가까이 둬야 한다
- 변수는 사용하는 위치에 최대한 가까이 선언한다
- 루프를 제어하는 변수는 흔히 루프 문 내부에 선언한다
- 잘 설계한 클래스는 많은 클래스 메서드가 인스턴스 변수를 사용하기 때문이다
- 종속함수. 한 함수가 다른 함수를 호출한다면 두 함수는 세로로 가까이 배치한다. 또한 가능하다면 호출하는 함수를 호출되는 함수보다 먼저 배치한다
- 개념적 유사성. 어떤 서로 끌어당긴다. 개념적인 친화도가 높기 때문이다. 친화도가 높을수록 코드를 가까이 배치한다
- 신문기사와 마찬가지로 가장 중요한 개념을 가장 먼저 표현한다.
- 가장 중요한 개념을 표현할 때는 세세한 사항을 최대한 배제한다.
- 팀은 한 가지 규칙에 합의해야 한다
- 그리고 모든 팀원은 그 규칙을 따라야 한다. 그래야 소프트웨어가 일관적인 스타일을 보인다.