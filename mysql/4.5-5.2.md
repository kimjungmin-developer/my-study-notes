## 4.5 MySQL의 격리수준
- 트랜잭션 격리 수준이란 동시에 여러 트랜잭션이 처리될떄, 특정 트랜잭션이 다른 트랜잭션에서 변경하거나 조회하는 데이터를 볼 수 있도록 허용할지 말지를 결정하는 것이다.
- 크게 "Read Uncommitted", "Read Committed", "Repetable Read", "Seriazlizable"로 나뉜다.
- 4개의 격리수준에서 순서대로 뒤로 갈수록 트랜잭션간의 데이터 격리 정도가 높아지며, 동시에 동시성도 떨어진다
- p.192 표 참조
- InnoDB에서는 독특한 특성 때문에 Repeatable Read격리 수준에서도 Phantom Read가 발생하지 않는다

## Read Uncommitted
- 어떤 트랜잭션에서 처리한 작업이 완료되지 않았는데도 다른 트랜잭션에서 볼 수 있게 되는 현상을 더티리드라고 하고, 더티 리드가 허용되는 격리 수준이 Read Comitted.(즉, 트랜잭션이 시작되고 commit/rollback이 동작하기 전에 접근 할 수 있다는 말이다!)
- 더티 리드 현상은 데이터가 나타났다가 사라졌다가 하는 현상을 초래하므로 애플리케이션 개발자와 사용자를 상당히 혼란스럽게 만들 것이다. 
- Read Uncomitted은 표준에서는 트랜잭션의 격리 수준으로 인정하지 않을 정도로 정합성에 문제가 많은 격리 수준이다.

## Read Committed
- 온라인 서비스에서 가장 많이 사용되는 격리 수준이다! 직잭은?
- 더티리드 발생안함
- 어떤 트랜잭션에서 데이터를 변경했더라도 commit이 완료된 데이터만 다른 트랜잭션에서 조회할 수 있기 때문이다.
- 언두영역을 적극 사용한다(Undo 영역)
- 언두 레코드는 트랜잭션의 격리 수준을 보장하기 위한 용도뿐 아니라 트랜잭션의 Rollback에 대한 복구에도 사용된다.
- Repeatable Read란? 똑같은 Select쿼리를 실행했을때는 항상 같은 결과를 가져와햐 한다는 정합성에 관한 것이다.
- Read Committed에서는 Non-repeatable read가 발생 할 수 있다.

## Repeatable Read
- 금융권에서 중요할 듯 합니다!
- 바이너리 로그를 가진 MySql 장비에서는 최소 Repeatable Read격리 수준 이상을 사용해야 한다.
- Non-Repetable 부정합 발생하지 않는다.
- InnoDB 스토리지 엔진은 트랜잭션이 rollback될 가능성에 대비해 전 레코드를 Undo공간에 백업해둔다.
- Undo Record를 사용한다는 의미는 MVCC(Multi Version Concurrency Control)를 한다는 의미다.
- Repeatable Read는 이 MVCC를 위해 언두 영억에 백업된 어전 데이터를 이용해 동일 트랜잭션 내에서는 동일한 결과를 보여줄 수 있도록 보장한다.
- 근데 아까 위에서 읽었듯이 Read Commited에서도 Undo영역을 사용한다
- (중요) Read Committed vs Repeatable Read에서 가장 중요한 것은 언두 영억에 백업된 레코드의 여러 버전 가운데 몇 번째 이전 버전까지 찾아 들어가야 하는 지에 있다.
- 모든 InnoDB의 트랜잭션은 고유한 트랜잭션 번호를 가지며, 언두 영역에 백업된 모든 레코드에는 변경을 발생시킨 트랜잭션 번호가 포함돼 있다.
- Repeatable Read격리 수준에서즌 MVCC를 보장하기 위해 실행 중인 트랜잭션 가운데 가장 오래된 트랜잭션 번호보다 트랜잭션 번호가 앞선 언두 영역의 데이터는 삭제할 수 없다.
- 특정 트랜잭션 번호의 구간 내에서 백업된 언두 데이터가 보존돼야 하는 것이다.
- 실행중인 트랜잭션 번호는 자기보다 작은 번호를 바라보게 된다!
- 하지만 예외는 존재한다 ==>Phantom-Read가 존재한다(>5000같이 범위로 했을때이다!)

## Serializable
- 가장 단순한 격리 수준이지만 가장 엄격한 격리 수준이다.
- 동시 처리 성능도 다른 트랜잭션격리 수준보다 떨어진다
- ==> 한 트랜잭션에서 읽소 쓰는 레코드를 다른 트랜잭션에서는 절대 접급 할 수 없는 것이다.

## 성능비교
- 별 차이 없는 것 같습니다! RepeatableRead ㄱ ㄱ

## 5.1 데이터 읽기 방식
- 데이터베이스의 성능 튜닝은 어떻게 디스크 I/O를 줄이느냐가 관건인것들이 상당히 많다
- 컴퓨터에서 CPU나 메모리와 같은 주요 장치는 대부분 전자식 장치지만 디스크 드라이브는 기계식 장치다.
- 따라서 데이터베이스 서버에서는 항상 디스크 장치가 병목 지점이 된다.
- 디스크의 헤더를 움직이지 않고 한벙에 많은 데이터를 읽는 순차I/O에서는 SSD가 디스크 드라이브보다 조금 빠르거나 거의 비슷한 성능을 보이기도 한다. 하지만 SSD의 장점은 기존의 디스크 드라이브 보다 랜덤I/O가 훨씬 빠르다는 것이다. 데이터베이스 서버에서 순차 I/O작업은 그다지 비중이 크지 않고 랜덤 I/O를 통해 작은 데이터를 읽고 쓰는 작업이 대부분이므로 SSDㅇ의 장점은 DBMS용 스토리지에 최적이라고 볼 수 있다. 
- 디스크의 성능은 디스크 헤더의 위치 이동 없이 얼마나 많은 데이터를 한번에 기록하느냐에 의해 결정된다고 볼 수 있다. 그래서 여러 번 쓰기 또는 읽기를 요청하는 랜덤 I/O 작업이 훨씬 작업의 부하가 커지는 것이다.
- 데이터베이스 대부분의 작업은 이러한 작은 데이터를 빈번히 읽고 쓰기 때문에 MySQL서버에는 그룹커밋이나 바이너리 로그 버퍼 또는 InnoDB로그 버포 등의 기능이 내장된 것이다.
- 결론: 일반적으로 쿼리를 튜닝하는 것은 랜덤 I/O자체를 줄이는 것이 목적이라고 할 수 있다. 여기서 랜덤 I/O를 줄인다는 것은 쿼리를 처리하는 데 꼭 필요한 데이터만 읽도록 쿼리를 개선하는 것을 의미한다.

## 5.2 인덱스란?
- DBMS도 데이터베이스 테이블릐 모든 데이터를 검색해서 원하는 결과를 가져오려면 시간이 오래 걸린다.
- 그래서 칼럼의 값가 해당 레커드가 저장된 주소를 키와 값의 쌍으로 인덱스를 만들어 두는 것이다.
- SortedList는 DBMS의 인덱스와 같은 자료구조이며, ArrayList는 데이터 파일과 같은 자료구조를 사용한다. SortedList는 정장되는 값을 항상 정렬된 상태로 유지하는 자료구조이며, ArrayListsms 값을 저장한 순서대로 그대로 유지하는 자료구조이다. 
- DBMS의 인덱스도 SortedList와 마찬가지로 저장되는 칼럼의 값을 이용해 항상 정렬된 상태로 유지한다.
- 데이터 파일은 ArrayList와 같이 저장된 순서대로 별도의 정렬없이 그대로 저장해둔다.
- SortedList자료구조는 데이터가 저장될 때마다 항상 값을 정렬해야 하므로 저장하는 과정이 복잡하고 느리지만 이미 정렬돼 있어서 아주 빨리 원하는 값을 찾아올 수 있다.
- 인덱스도 인덱스가 많은 데이블은 당연히 Insert, Update, Delete는 느리다.
- 하지만 이미 정렬된 찾아보기용 표를 가지고 있기 때문에 Select문장은 매우 빠르게 처리된다.
- 결론적으로 DBMS에서 인덱스의 데이터의 저장선을 희생하고 그대신 데이터 읽기 속도를 높이는 기능이다.
- 대표적인 인덱스 알고리즘은 Balanced-Tree, Hash, Fractal-Tree이다

## 생각해볼 거리:
- 트랜잭션 내에서 실행되는 Select란 무엇을 뜻하는가?  p.195
- 왜 Phantom-Read가 발생하도록 디자인 했을까요? p.197
- Phantom-Read가 발생한다는 것일까요 아닐까요? p.198
- 바이너리 로그는 정확히 무엇일까요? p.199

