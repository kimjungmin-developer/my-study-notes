# 5.7-5.12

## 5.7 전문 검색 인덱스
- 문서의 내용 전체를 인덱스화해서 특정 키워드가 포함된 문서를 검색하는 전문 검색에는 b-tree인덱스를 사용할 수 없다
- 전문 검색 인덱스에는 문서의 키워드를 인덱싱하는 기법에 따라 크게 구분자와 N-그램으로 나눠서 생각해 볼 수 있다

### 구분자 기법
- 전문의 내용을 공백이나 탭 또는 마침표와 같은 문장 기호, 그리고 사용자가 정의한 문자열을 구분자로 등록한다.
- 구분자 기법은 이처럼 등록된 구분자를 이용해 키워드를 분석해내고, 결과 단어를 인덱스로 생성해 두고 검색에 이용하는 방법을 말한다
- 구분자 기법은 문서의 본문으로부터 키워드를 추출해 내는 작업이 추가로 필요할 뿐, 내부적으로는 b-tree인덱스를 그대로 사용한다

### N-GRAM 기법
- 엔그램이란 본문을 무조건적으로 몇 글자씩 잘라서 인덱싱하는 방법이다
- 구분장에 의한 방법보다는 인덱싱 알고리즘이 복잡하고, 만들어진 인덱스도 상당히 큰 편이다
- 2-Gram 인덱싱 기법은 2글자 단위의 최소 키워드에 대한 키를 관리하는 프런트엔드 인덱스와 2글자 이상의 키워드 묶음을 관리하는 백엔드 인덱스 2개로 구성된다
- 인덱스 생성 과정: 1. 문서의 본문을 2글자보다 큰 크기로 블록을 구분해서 백엔드 인덱스를 생성 2. 백엔드 인덱스의 키워드들을 2글자씩 잘라서 프런트엔드 인덱스를 생성
- 입력된 검색어를 2바이트 단위로 동일하게 잘라서 프론트엔드 인덱스를 검색한다.
- 그 결과를 대상 후보 군으로 선정하고, 백엔드 인덱스를 통해 최종 검증을 거쳐 일치하는 결과를 가져온다
```mysql
SELECT * FROM tb_test WHERE MATCH(doc_body) AGAINST('아이퐁' IN BOLLEAN MODE);
```
- 전문 검색 인덱스를 사용하려면 반드시 MATCH, AGAINST 구문으로 검색 쿼리를 작성해야 하며, MATCH 절의 괄호에 포함되는 내용은 반드시 사용할 전문 검색 인덱스에 정의된 칼럼이 모두 명시돼야 한다

## 5.8 비트맵 인덱스와 함수 기반 인덱스
- 테이블에 함수의 결과 값을 저장하기 위한 칼럼을 추가하고, 크 칼럼에 인덱스를 생성해서 사용하면 된다

## 5.9 클러스터링 인덱스
- 인덱스에서 클러스터링은 값이 비슷한 것들을 묶어서 저장하는 형태로 구현되는데, 이는 주로 비슷한 값들을 동시에 조회하는 경우가 많다는 점에 착안한 것이다.
- MySQL에서 클러스터링 인덱스는 INNODB와 TokuDB스토리지 엔진에서만 지원하며 나머지 스토리지 엔진에서는 지원되지 않으므로 이번 절의 내용은 대두분 이 두가지 스토리지 엔진에만 해당한다
- 클러스터링 인덱스는 테이블의 프라이머리 키에 대해서만 적용되는 내용이다.
- 즉 프라이머리 키값이 비슷한 레코드끼리 묶어서 저장하는 것을 클러스터링 인덱스라고 표현한다
- 일반적으로 INNODB와 같이 항상 클러스터링 인덱스로 저장되는 테이블은 프라이머리 키 기반의 검색에 매우 빠르며, 대신 레코드의 저장이나 프라이머리 키의 변경이 상대적으로 느릴 수 밖에 엄ㅎ다
- B-Tree의 리프 노드와는 달리 클러스터링 인덱스의 리프노드에는 레코드의 모든 칼럼이 같이 저장돼 있음을 알 수 있다
- 즉 클러스터링 테이블은 그 자체가 하나의 거대한 인덱스 구조로 관리되는 것이다???
- INNODB 스토리지 엔진이 적절한 클러스터 키 후보를 찾지 못해서 내부적으로 자동 증가 칼럼을 추가한 경우, 자동 추가된 사용자에게 노출되지 않으며, 쿼리 문장에 명시적으로 사용할 수 없다
  1. 프라이머리 키가 있으면 기본적으로 프라이머리 키를 클러스터 키로 선택
  2. NOT NULL 옵션이 유니크 인덱스 중에서 천 번째 인덱스를 클러스터 키로 선택
  3. 자동으로 유니크한 값을 가지도록 중가되는 칼럼을 내부적으로 추가한 후, 클러스터 키로 선택
- 클러스터 키값이 변경될때마다 데이터 레코드의 주소가 변경되고 그때마다 해당 테이블의 모든 인덱스에 저장된 주소 값을 변경해야 할 것이다. 
- 이런 번거로움을 방지하고자 INNODB테이블의 모든 보조 인덱스는 해당 레코드가 저장된 주소가 아니라 프라이머리 키값을 저장하도록 구현돼 있다
- MYISAM vs INNODB:
  - MYISAM은 ix_firstname 인덱스를 검색해서 레코드 주소를 확인 레코드의 주소를 이용해 최종 레코드를 가져 옴
  - INNODB는 ix_fistname 인덱스를 검색해서 레코드의 프라이머리 키값을 확인해 프라이머리 키 값을 이용해 다시 한번 테이블을 검색한 후에 최종 레코드를 가져옴
- 유니크 인덱스의 읽기: 유니크하지 않은 보조 인덱스에서 한 번 더 해야 하는 작업은 디스크 읽기가 아니라 CPU에서 칼럼값을 비교하는 작업이기 때문에 이는 성능상의 영향이 거의 없다고 볼 수 있다. 유니크하지 않은 보조 인덱스는 중복된 값이 허용되므로 읽어야 할 레커드가 많아서 느린 것인지, 인덱스 자쳉듸 특성 때문에 느린 것이 아니라는 것이다
- 유니크 인덱스 쓰기: 새로운 레코드가 INSERT되거나 인덱스 칼럼의 값이 변경된느 경우에는 인덱스 쓰기 작업이 필요하다. 그런데 유니크 인덱스의 키값을 쓸때는 중복된 값이 있는지 없는지 체크하는 과정이 한 단계 필요하다. 그래서 일반 보조 인덱스의 쓰기보다 느리다. INNODB스토리 엔진에는 인덱스의 키의 저장을 버퍼링하기 위해 인서트 버퍼가 사용된다. 그래스 인덱스의 저장이나 변경 작업이 상당히 빨리 처리되지만 안타깝게도 유크 인덱스는 반드시 중복 체크를 해야 하므로 작업 자체를 버퍼링하지 못한다. 이 때문에 유니크 인덱스는 일반 보조 인덱스보다 더 느려진다
- 유니크인덱스가 더 좋은 성능으로 가지 않는다
- 유니크엔딕스를 중복해서 생성하지 않는다(프라이머리 키)

## 5.11 외래키
- 테이블의 변경이 발생하는 경우에만 잠금 경합이 발생한다 (자식, 부모)
- 외래키와 연관되지 않은 칼럼의 변경은 최대한 잠금 경합을 발생시키지 않는다
- 자식 테이블의 외래키 칼럼의 변경은 부모 테이블의 확인이 필요한데, 이 상태에서 부모 테이블의 해당 레코드가 쓰기 잠금이 걸려 있다면 해당 쓰기 자금이 해제될 때까지 기다리게 되는 것이다, 다른 칼럼이엇다면 잠금이 걸리지 않았을 것이다
- 자식 테이블이 생성될 때 정의된 외래키의 특성때문에 부모 레코드가 삭제되면 자식 레코드가 동시에 삭제되도록 작동하기 때문에 부모를 지우려고 하면 자식이 잠긴다

## 5.12 기타 주의사하아
- MyISAM: B-Tree, R-Tree, Fulltext-index
- INNODB: B-Tree
- MEMORY: B-Tree, Hash
- TOKUDB: Fractal Tree
- NDB: Hash, B-Tree