# 4.1-4.4

## Overview
- 트랜잭션은 작업의 완전성을 보장해 주는 것이다. 따라서 하나의 논리작업 = 모두 성공 또는 모두 실패 (Partial Update를 방지한다)
- 잠금과 트랜잭션은 서로 비슷한 개념 같지만 다른 개념이다. 잠금은 동시성을 제어하기 위한 기능이고 트랜잭션은 데이터의 정합성을 위한 것이다.
- 잠금: 하나의 회원 정보를 여러 커넥션에서 동시에 변경 ==> 예측 불가능
- 격리수준(트랜잭션): 하나의 트랜잭션 내에서 또는 여러 트랜잭션 간의 작업 내용을 어떻게 공유하고 차단할 것인지를 결정하는 레벨이다.
- jm: 트랜잭션이 잠금이라는 개념을 활용하는 것 같습니다.


## 4.1 트랜잭션
- MyISAM, MEMORY Storage Engine, MERGE Storage Engine: transaction not supported
- InnoDB: transaction supported
- 트랜잭션은 하나의 논리적인 작업 셋에 하나의 쿼리가 있든 두 개 이상의 쿼리가 있든 상관없이 논리적인 작업 셋 자체가 100% 적용되거나 또는 아무것도 적용되지 않아야 한다.
- 일반적으로 데이터베이스 커넥션은 개수가 제한적이라서 각 단위 프로그램이 커넥션을 소유하는 시간이 길어질수록 사용 가능한 여유 커넥션의 개수는 줄어들 것이다. 그리고 어느 순간에는 각 단위 프로그램에서 커넥션을 가져가기 위해 기다려야 하는 상황이 발생할 수도 있다. (트랜잭션 범위를 필요한 만큼만 가져가자!)
- 메일 전송이나 ftp 파일 전송 작업 또는 네트워크를 통해 원격 서버와 통신하는 등과 같은 작업은 어떻게 해서든 DBMS의 트랜잭션 내에서 제거하는 것이 좋다.
- 성격이 비슷한 작업끼리 한 트랜잭션에 묶어야 한다.
- 단순 조회는 트랜잭션이 필요하지 않을 수도...?

## 4.2 MySQL 엔진의 잠금
- MySQL의 사용하는 잠금은 스토리지 엔진레벨(INNODB, MyISAM)과 MySQL엔진 레벨로 나눠 볼 수 있다.  
- MySQL 엔진 레벨의 잠금은 모든 스토리지 엔진에 영향을 미치게 되지만 스토리지 엔진 레벨의 잠금은 스토리지 엔진 간 상호 영향을 받지 않는다.
- MySQL엔진의 Global Lock: 
  - "Flush Tables With Read Lock"명령으로만 획득가능하다. 
  - 어떤 세션에서 글로발락을 획득할 경우 Select문 빼고는 막힌다
  - mysqldum로 일관된 백업을 받아야할 때 글로벌 락을 사용해야한다.
  - 모든 테이블에 락을 건다.
- MySQL엔진의 Table Lock:
  - 개별 테이블 단위로 설정되는 잠금이며, 명시적 묵시적으로 특정 테이블의 락을 획둑할 수 있다.(레코드나 로우가 아니다!)
  - "Lock Tables table_name [READ|WRITE]"명령으로 특정 테이블의 락을 획득할 수 있다.
  - 묵시적인 테이블락이라는 것이 존재하는데 묵시적인 테이블락은 쿼리가 실행되는 동안 자동적으로 획득했다가 쿼리가 완료된 후에 자동 해제된다. 하지만 innodb는 아니다!!
- UserLock: 특정 String에 해당
- NameLock: 이름을 변경할 때 발생

## 4.3 MyISAM과 MEMORY 스토리지 엔진의 잠금(안중요해보임)
- MyISAM이나 MEMORY스토리지 엔진은 자체적인 잠금을 가지지 않고 MySQL엔진에서 제공하는 테이블락을 그대로 사용한다. 
- ARHIVE, MERGE STORAGE도 마찬가지이다.
- "SHOW STATUS LIKE Table%"를 사용하면 상태변수를 확인 할 수 있다.
- MyISAM이나 MEMORY등과 같은 스토리지 엔진을 사용하는 테이블은 모두 테이블 단위의 잠금이므로 테이블을 해제하지 않으면 다른 클라이언트에서 그 테이블을 사용하는 것이 불가능하다 ==> 동시성의 성능이 떨어진다
- 'Show ProcessList'로 테이블을 잠금상황을 볼 수 있다.

## 4.4 INNODB 스트로지 엔진의 잠금
- 레코드 기반의 잠금
- 비관적 잠금: 각 트랜잭션이 같은 레코드를 변경할 가능성은 높다라는 가정, 많은 동시성처리를 할 때 유리하다, InnoDB방식
- 낙관적 잠금: 각 트랜잭션이 같은 레코드를 변경할 가능성은 낮다라는 가정
- InnoDB잠금은 잠금 정보가 상당히 작은 공간으로 관리되기 때문에 레코드 락이 페이지 락으로 또는 테이블 락으로 레벨업 되는 경우는 없다(락 에컬레이션이 없다)
- InnoDB에서의 락:
  - 레코드 락: 1. 레코드 자체가 아니라 인덱스 레코드를 잠금다(인덱스가 없는 테이블이라면? 내부적으로 자동 생성된 클러스터 인덱스를 이용해 잠금을 설정한다) 2. 프라이머리 키 또는 유니크 인덱스에 의한 변경 작업은 갭에 대한 잠금이 아니라 레코드락이 걸린다.
  - 갭 락: 갭락은 레코드 그 자체가 아니라 바로 인접한 레토드 사이의 간격만을 잠그는 것이다. 갭락의 역할은 레코드와 레코드 사이의 간격에 새로운 레코드가 생성되는 것을 제어하는 것이다. 갭락은 넥스트 키 락에 의해서 활용된다.
  - 넥스트 키 락: 넥스트키 락 = 1. 레코드 락 + 갭 락 2. 갭 락이나 넥스트 키 락은 바이너리 로그에 기록되는 쿼리가 슬레이브에서 실행될 때 마스터에서 만들어낸 결과와 동일한 결과를 만들어내도록 보장하는 것이 주목적이다.
  - 자동 증가 락: MySQL에서는 자동 증가하는 숫자 값을 추출하기 위해 AUTO_INCREMENT라는(JPA에서 쓰는 그것인것 같습니다)칼럼 속성을 제공한다. AUTO_INCREMENT 칼럼이 사용된 테이블에 동시에 여러 레코드가 INSERT가 되는 경우, 저장되는 각 레코드는 중복되지 않고 저장된 순서대로 증가한 일련번호 값을 가져야 한다. INSERT, REPLACE 쿼리문에만 해당한다. 
- */중요/* InnoDB 잠금은 레코드를 잠그는 것이 아니라 인덱스를 잠그는 방식으로 처리된다. 즉 변경해야 할 레코드를 찾기 위해 검색한 인덱스의 레코드를 모두 잠가야 한다.(InnoDB에서 Index설계가 중요한 이유이다)
- 예를들어, first_name이라는 column에 index가 걸려있고 'UPDATE employees SER hire_date=NOW() WHERE first_name='Georgi' AND last_name='Klassen'쿼리를 날렸을때 first_name=Georgi에 해당하는 모든 레코드에 락이 걸린다.
- 만약, first_name도 index가 걸려있지 않다면 풀스캔을 이행한다(최악이다).
- 따라서 MySql에서는 인덱스 설계가 중요하다!
- 넥스트 키 락을 하는 이유는 ==> 복제를 위해 바이너리 로그때문이다. 
- 트랜잭션 상태를 확인하기 위해서는 INFORMATION_SCHEMA라는 DB에 INNODB_TRX, INNODB_LOCKS, INNODB_LOCK_WAITS테이블을 조합해서 보면 된다.
- INNODB_TRX = 어떤 트랜잭션이 어떤 클라이언트에 의해 기동되고 있으며, 어떤 잠금을 기다리고 있는지를 관리한다.
- INNODB_LOCK_WAITS = 잠금에 의한 프로세스 간의 의존 관계를 관리한다.
- p.190참조