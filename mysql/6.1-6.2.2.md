# 6.1-6.2.2

## 6.1
- MySQL서버에서 쿼리가 실행되는 과정은 크게 3가지로 나눌 수 있다:
  1. 사용자로부터 요청된 SQL 문장을 잘게 쪼개서 MySQL 서버가 이해할 수 있는 수준으로 분리한다
  2. SQL의 파싱 정보(파스 트리)를 확인하면서 얻너 테이블을 일고 어떤 인덱스를 이용해 테이블을 읽을지 선택한다
  3. 두번째 단계에서 결정된 테이블의 읽기 순서나 선택된 인덱스를 이용해 스토리지 엔진으로부터 데이터를 가져온다

- 첫번째 단계를 에스큐엘 파싱이라고 하며, 마이에스큐엘 서버의 SQL PARSER라는 모듈로 처리한다.
- 만약 SQL문장이 문법적으로 잘못됐다면 이 단계에서 걸러진다
- 두번째는 첫번째에서 만들어진 파스트리를 보면서:
  - 불필요한 조건의 제거 및 복잡한 연산의 단순화
  - 여러 테이블의 조인이 있는 경우 어떤 순서로 테이블을 읽을지 결정
  - 각 테이블에 사용된 조건과 인덱스 통계 정보를 이용해 사용할 인덱스 결정
  - 가져온 레코드들을 임시 테이블에 넣고 다시 한번 가공해야 하는지 결정
- 두 번쩨 단계는 "최적화 및 실행계획 수립"단계이며 MYSQL OPTIMIZER가 처리한다 = 핵심이다
- 세번째 단계는 실행 계획대로 스토리지 엔진에 레코드를 읽어오도록 요청하고 MySQL엔진에서는 스토리지 엔진으로부터 받은 레코드를 조인하거나 정렬하는 작업을 수행한다

- 옵티마이저의 종류:
  1. 규칙 기반 최적화는 기본적으로 대상 테이블의 레코드 건수나 선택도 등을 고려하지 않고 옵티마이저에 내장된 우선 순위에 따라 실행 계획을 수립하는 방식을 의미한다
  2. 비용 기반 최적화는 쿼리를 처리하기 위한 여러가지 가능한 방법을 만들고, 각 단위 작업의 비용 정보와 대상 테이블의 예측된 통계 정보를 이용해 각 실행 계획별 비용을 산출한다
- 현재는 거의 대부분의 RDBMS가 비용 기반의 옵티마이저를 채택하고 있으며, MYSQL역시 마찬가지다
- 통계정보란?
  - 비용 기반 최적화에서 가장 중요한 정보는 통계정보다
  - 통계 정보가 정확하지 않다면 전혀 엉뚱한 방향으로 쿼리를 실행해 버릴 수 있기 때문이다
  - 예를들어 1억 건의 레코드가 저장된 테이블의 통계 정보가 갱신되지 않아서 레코드가 10건 미만인 것처럼 돼 있다면 옵티마이저는 실제 쿼리 실해 시에 인덱스 레인지 스캔이 아니라 테이블을 처음부터 끝까지 읽을 것이다: 0.1초 => 1시간
  - 기본적으로 MySQL에서 관리되는 통계 정보는 대략의 레코드 건수와 인덱스의 유니크한 값의 개수 정도가 전부다
  - 하지만 레코드 건수가 많지 않으면 통계 정보가 상당히 부정확한 경우가 많으므로 "ANALYZE"명렬을 이용해 강제적으로 통계 정보를 갱신해야 할 때도 있다

### EXPLAIN: ID 칼럼
- 한 sql문마다 있는 select의 갯수다
### EXPLAIN: SELECT_TYPE 칼럼
- UNION이나 서브 쿼리를 사용하지 않는 단순한 SELECT쿼리인 경우, 해당 쿼리 문장의 select_type은 SIMPLE로 표시된다(쿼리에 조인이 포함된 경우에도 마찬가지다). 쿼리 문장이 아무리 복잡하더라도 실행계획에서 select type이 SIMPLE인 단위 쿼리는 반드시 하나만 존재한다
- UNION이나 서브 쿼리가 포함된 셀렉트 쿼리가 실행계획에ㅐ서 가장 바깥쪽에 있는 단위 쿼리는 select_type이 PRIMARY로 표시된다
- UNION으로 결합하는 단위 SELECT쿼리 가운데 첫번째를 제외한 두 번째 이후 단위 SELECT쿼리의 SELECT_TYPE은 UNION으로 표시한다
- 내부의 쿼리가 외부의 값을 참조해서 처리될 때 = DEPENDENT
- UNION 결과를 담아둔다 = UNION RESULT
- FROM 절 이외에서 사용되는 서브 쿼리 = SUBQUERY, MYSQL의 실행계획에서 FROM절에 사용된 서브 쿼리는 DERIVED라고 표시되고 그 밖의 위치에서 사용되는 서브 쿼리는 전부 SUBQUERY라고 표시된다
- SELECT되는 칼럼에 사용되는 서브 쿼리 = NESTED QUERY
- WHERE절에 사용된 쿼리 = SUB QUERY
- FROM절에 사용된 서브 쿼리를 MYSQL에서는 파생테이블이라고 하며, 일반적으로 RDBMS전체적으로 인라인뷰또는 서브 셀렉트라고 한다
- 스칼라 서브 쿼리 = 하나의 값만 반환하는 쿼리
- 로우 서브 쿼리 = 칼럼에 개수에 관계없이 하나의 레코드만 반환하는 쿼리
- 안쪽 서브쿼리가 바깥쪽 SELECT쿼리의 칼럼에 의존적이라서 DEPENDENT 키워드가 붙는다
- 서브쿼리가 FROM절에 사용된 경우 MYSQL은 항상 SELECT_TYPE이 Derived인 실행 계획을 만든다
- Derived은 단위 Select 쿼리의 실행 결과를 메모리나 디스크에 임시 테이블을 생성하는 것을 의미한다
- 파생 테이블에는 인덱스저 젼호 없으므로 테이블과 조인할 때 성능상 불리할 때가 많다
- 쿼리를 튜닝하기 위해 실행 계획을 확인할 때 가장 먼저 select_type칼럼의 ㄱ밧의 DERIVED인 것이 있는지 확인해야 한다
- 다른 방법이 없어서 서브 쿼리를 사용하는 것은 피할 수 없다.
- 하지만 조인으로 해결할 수 있느 경우라면 서브쿼리보다는 무조건 조인이다
- UNCACHEABLE SUBQUERY:
  1. 사용자 변수가 서브쿼리에 사용된 경우
  2. NOT_DETERMINISTIC 속성의 스토어드 루틴이 서브 쿼리 내에 사용된 경우
  3. UUID(), RAND()와 같이 결과값이 호출할 때마다 달라지는 함수가 서브 쿼리에 사용되는 경우
