# 5.3

## 5.3 Overview
- B-Tree = Balanced Tree NOT Binary Tree

## 5.3.1
- 루트노트가 존재하고 그 하위에 자식 노드가 붙어 있는 형태다
- NOT Leaf Node AND NOT Root Node = Branch Node
- 데이터베이스에서 인덱스와 실제 데이터가 저장된 데이터는 따로 관리되는데, 인덱스의 리프 노드는 항상 실제 데이터 레코드를 찾아가이 위한 주소 값을 가지고 있다.
- 인덱스의 키값은 모두 정렬돼 있지만 데이터 파일의 레코드는 정렬돼 있지 않고 임의의 순서대로 저장돼 있다.
- 인덱스는 테이블의 키 칼럼만 가지고 있으므로 나머지 칼럼을 읽으려면 데이터 파일에서 해당 레코드를 찾아야 한다.
- InnoDB 테이블에서 프라이머리 키에 의해 클러스터링되기 때문에 프라이머리 키값 자테가 주소 역할을 한다.


## 5.3.2
- B-Tree에 저장될 때는 키값을 이용해 B-Tree상의 적절한 위치를 검색해야 한다. 저장될 위치가 결정되면 레코드의 키값과 대상 레코드의 주소 정보를 B-Tree의 리프 노드에 저장한다. 만약 리프노드가 꽉 차서 더는 저장할 수 없을 때는 리프 노드가 분리되야 하는데. 이는 상위 브랜치 노드까지 처리의 범위가 넓어진다. 이러한 작업 탓에 B-Tree는 상대적으로 쓰기 작업에 비용이 많이 드는 것으로 알려졌다.
- 인덱스 쓰기 비용 = 테이블에 레코드를 추가하는 비용(1) + 인덱스 비용(1.5)
- ex) 인덱스가 3개인 테이블에 1나 추가할 때 비용 = 1 + 1.5*3
- InnoDB 스토리지 엔진은 인덱스 쓰기를 지능적으로 처리한다 ==> 바로 vs 지연 (선택)
- InnoDB 스토리지 엔진의 인서트 버퍼는 MySQL5.1 이하에서는 INSERT로 인한 인덱스 키 추가 작업만 버퍼링 및 지연처리를 할 수 있었다.
- 하지만 MYSQL 5.5 이상의 버전에서는 INSERT뿐 아니라 DELETE 등에 의한 인텍스 키의 추가 및 삭제 작업까지 버퍼링해서 지연처리할 수 있게 기능 확장되었다.
- 인덱스 키 삭제: 해당 키값이 저장된 B-Tree의 리프 노드를 찾아서 그냥 삭제 마크만 하면 작업이 완료된다. 이렇게 삭제 마킹된 인덱스 키 공간은 계속 그대로 방치하거나 또는 재활용 할 수 있다. 인덱스 키 삭제로 인한 마킹 작업 또한 디스크 쓰기가 필요하므로 이 작업 역시 디스트 I/O가 필요한 작업이다 (5.5부터는 이것도 지연로직 가능)
- MYISAM이나 MEMORY STORAGE 엔진은 인서트 버퍼가 없다
- B-TREE의 키값 변경 작업은 먼저 키값을 삭제한 후, 다시 새로운 키값을 추가하는 형태이다
- INSERT, UPDATE, DELETE 작업을 할 때 인덱스 관리에 따르는 추가 비용을 감당함녀서 인덱스를 구축하는 이뉴는 바로 빠른 검색을 위해서다
- 인덱스를 검색하는 작업은 B-Tree의 루트 노드로부터 시작해 브랜치 노드를 거쳐 최종 리프 노드까지 이동하면서 비교 작업을 수행하는데, 이 과정을 "트리 탐색"이라고 한다
- B-Tree 인덱스를 이용한 검색은 100%일치 또는 값의 앞부분만일치하는 경우에 사용할 수 있다(왼쪽부터 차례대로)
- 부등호 비교나 값의 뒷부분이 일치하는 경우에는 B-Tree 인덱스를 이용한 검색잉 불가능하다
- 또한 인덱스을 이용한 검색에서 중요한 사실은 인덱스의 키값에 변형이 가해진 후 비교되는 경우에는 절대 B-Tree의 빠른 검색 기능을 사용할 수 없다는 것이다
- InnoDB테이블에서 지원하는 레코드 잠금이나 넥스트 키 락이 검색을 수행한 인덱스를 잠근 후 테이블의 레코드를 잠그는 방식으로 구현되어 있다.
- 따라서 Update나 Delete 문장이 실행될 때 테이블에 적절히 사용 할 수 있는 인덱스가 없으면 불필요하게 많은 레코드를 잠근다

## 5.3.3
인덱스키 크기
- InnoDB Storage Engine은 디스크에 데이터를 저장하는 가장 기본 단위를 페이지 또는 블록이라고 하며, 디스크의 모든 읽기 및 쓰기 작업의 최소 작업 단위가 된다. 또한 페이지는 INNODB스토리지 엔진의 버퍼 풀에서 데이터를 버퍼링하는 기본 단위이기도 하다.
- 인덱스도 결국은 페이지 단위로 관리되며, 위의 B-Tree 그림에서 루트와 브랜치, 그리고 리프 노드를 구분한 기분이 바로 페이지 단위다
- 일반적으로 DBMS의 B-Tree는 자식 노드의 개수가 가변적인 구조다. 그러면서 MySQL의 B-Tree는 자식 노드를 몇개까지 가질지가 궁금할 것이다. 그것은 바로 인덱스 페이지의 크기와 키값의 크기에 따라 결정된다. 이노디비의 모든 페이지 크기는 16KB로 고정되있다.
- 자식노드 585 vs 자식노드 372: SELECT 쿼리가 레코드 500개를 읽어야 한다면 전자는 인덱스 페이지 한번으로 해결될 수 있지만, 후자는 최소 2번 이상 디스크로부터 읽어야 한다.
- 결국 인덱스를 구성하는 키값의 크기가 커지면 디스크로부터 읽어야 하는 회수가 늘고 느련진다
- INNODB의 버퍼풀이나 캐시 영역은 제한적이기 때문에 하나의 레코드를 위한 인덱스 크기가 커지면 커질수록 메모리에 캐시해 둘 수 있는 레코드 수는 줄어든다
비트리 깊이
- B-Tree 인덱스 깊이는 상당히 중요하지만 직접적으로 제어할 방법이 없다
- 비트리 깉이는 마이에스큐엘에서 값을 검색할 때 몇번이난 랜덤하게 디스크를 읽어야 하는지와 직결되는 문제다
- 결론적으로 인덱스 키값의 크기가 커지면 커질수록 하나의 인덱스 페이지가 담을 수 있는 인덱스 키값의 개수가 작아지고, 그 때문에 같은 레코드 건수라 하더라고 비트리의 깊이가 깊어져서 디스크 읽기가 더 많이 필요하게 된다는 것을 의미한다
- 키값의 크기는 가능하게 작게 만드는 것이 좋다는 것을 강조함
선택도(기수성)
- Selectivity = Cardinality
- 모든 인덱스 가운데 유니크한 값의 수를 의미한다
- 인덱스 키값 가운데 값이 많아지면 많아질수록 기수성은 낮아지고 동시에 선택도 또한 떨어진다
- 인덱스 선택도가 높을수록 대상이 줄어들기 때문에 그만큼 빠르게 처리된다
- 선택도가 좋지 않다고 하더라도 정렬이나 그룹핑과 같은 작업을 위해 인덱스를 만든느 것이 훨씬 나은 경우도 많다
- 인덱스가 항상 검색에만 사용되는 것은 아니므로 여러 가지 용도를 고려해 적절히 인덱스를 설계할 필요가 있다
- 인덱스에서 유니크한 값의 개수는 인덱스나 쿼리의 효율성에 큰 영향을 미치게 된다
레코드 수
- 인덱스를 통해 테이블의 레코드를 읽는 것은 인덱스를 거치지 않고 바로 테이블의 레코드를 읽는 것보다 높은 비용이 드는 작업이다
- 테이블에 레코드가 100만건 이 저장돼 있는데 그중에서 50만 건을 읽어야 하는 쿼리가 있다고 가정해 보자
- 이 작업은 전체 테이블을 모두 읽어서 필요없는 50만건을 버리는 것이 효율적일지, 인덱스를 통해 50만거난 읽어 오는 것이 효율적일지 판단해야 한다
- 일반적인 DBMS의 옵티마이저에서는 인덱스를 통해 레코드 1건을 읽는 것이 테이블에서 직접 레코드 1건을 읽는 것보다 4~5배 정도 비싸다
- 따라서 읽어야 할 레코드수가 전체 레코드수의 20~25%라면 인덱스를 이용하지 않고 직접 테이블을 모두 읽어서 필요한 레코드만 가려내는 방식으로 처리하는 것이 효율적이다
- 전체 100만건의 레코드 가운데 50만건을 읽어야 하는 작업은 인덱스의 손익 분기점인 20~25%보다 훨씬 크기 때문에 MySQL 옵티마이저는 인덱스를 이용하지 않고 직접 테이블을 처음부터 끝까지 읽어서 처리할 것이다

## 5.3.4 ~ 5.3.5 인덱스 스캔 방식
인덱스 레인지 스캔
- 인덱스 레인지 스캔은 검색해야 할 인덱스의 범위가 결정됐을 때 사용하는 방식이다
- 검색하려는 값의 수나 검색 결과 레코드 건수와 관계없이 레인지 스캔이라고 표현한다
- 루트노드에서부터 비교를 시작해 브랜치 노드를 거치고 최종적으로 리프 노드까지 찾아 들어가야만 비로소 실제로 원하는 시작 지점을 찾을 수 이 있다. 일단 시작해야할 위치를 찾으면 그때부터는 리프 노드의 레코드만 순서대로 읽으면 된다
- 리프 노드에 저장된 레코드 주소로 데이터 파일의 레코드를 읽어오는데, 레코드 한건 한건 단위로 랜덤아이오를 한번씩 실행한다 => 인덱스를 통해 데이터 레코드를 읽는 작업은 비용이 많이 드는 작업으로 분류되는 것이다 => 인덱스를 통해서 읽는 작업이 20~25% 넘으면 인덱스 사용이 효율적이지 못하다
인덱스 풀 스캔
- 인덱스의 처음부터 끝까지 모두 읽는 방식을 인덱스 풀스캔이라고 한다
- 다중칼럼 인덱스 일때 인덱싀 첩너빼 칼럼이 아닌 겨웅 인덱스 풀 스캔이 사용된다
- 일반적으로 인덱스의 크기는 테이브릐 크기보다 작으므로 직접 테이블을 처음부터 끝까지 읽는 것보다는 인덱스만 읽는 것이 효율적이다
- 인덱스 레인지 스캔보다는 빠르지 않지만 테이블 풀 스캔보다는 효율적이다
루스 인덱스 스캔
- 중간마다 필요하지 않는 인덱스 키값은 무시하고 다음으로 넘어가는 형태로 처리한다
- 일반적으로 Group By, MAX, MIN 함수에 대해 최적화를 하는 경우에 사용된다
- 그냥 무시하고 필요한 부분만 읽는 것이다. 루스 인덱스 조건은 6장에서...
다중 칼럼 인덱스
- 2개 이상의 칼럼을 포함하는 인덱스가 더 많이 사용된다
- 두 개 이상의 칼럼으로 구성된 인덱스를 다중 칼럼 인덱스라고 하며, 또한 2개 이상의 칼럼이 연결됐다고 해서 Concatenated Index라고 한다

## 5.3.6 인덱스의 정렬 및 스캔 방향
- 실제로는 ASC나 DESC 키워드를 무시하고 모든 칼럼이 오름차순으로 인덱스화한다
- 인덱스는 항상 오름차순으로 정렬돼 있지만 인덱스를 최소값으로 읽으면 오름차순으로 값을 가져올 수도 있고, 최대값부터 거꾸로 읽으면 내림차순으로 가져올 수 있나는 것을 MySQL OPTIMIZER는 이미 알고 있다
- 인덱스를 역순으로 정렬되게 할 수는 없지만 인덱스를 읽는 방향에 따라 오름차순 또는 내림차순 정렬 효과를 얻을 수 있다
- MYSQL OPTIMIZER는 인덱스의 읽기 방향을 전환해서 사용하도록 실행계획을 만든다

## 5.3.7 인덱스의 가용성
- 비트리의 인덱스의 특징은 왼쪽 값에 기준해서 오른쪽 값이 정렬대 있다는 것이다
- 왼쪽이라 함은 하나의 칼럼 내에서뿐만 아니라 다중 칼럼 인덱스의 칼럼에 대해서도 함께 적용된다
- Select * From employees Where fist_name Like '%mer' 안먹힌다
- Select * From dept_emp WHERE emp_np>=10144; 안먹힌다
- 인덱스가 칼럼순서대로 생성돼 있다면 인덱스의 선행 칼럼인 dept_no값 없이 emp_np값으로만 검색하면 인덱스를 효율적으로 사용할 수 없다
- p.231~233 가용성 효율성 판단

생각해볼 거리:
- p.221 왜 인덱스 풀스캔이 더 효율적인가? 어차피 모든 레코드를 순회하는 것이 아닌가?